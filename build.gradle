buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    maven {
      name = 'jcenter'
      url = 'https://jcenter.bintray.com/'
    }
    removeIf { it instanceof MavenArtifactRepository && it.url.host == 'files.minecraftforge.net' }
    removeIf { it instanceof MavenArtifactRepository && it.url.host == 'maven.minecraftforge.net' }
    maven {
      name = 'forge'
      url = 'https://maven.minecraftforge.net/'
    }
    maven {
      name = 'gradle'
      url 'https://plugins.gradle.org/m2/'
    }
    maven {
      name = 'sonatype'
      url = 'https://oss.sonatype.org/content/groups/public'
    }
  }
  dependencies {
    if (GradleVersion.current() >= GradleVersion.version('5.0')) {
      classpath group: 'gradle.plugin.com.github.spotbugs.snom', name: 'spotbugs-gradle-plugin', version: '4.7.1'
    } else if (GradleVersion.current() >= GradleVersion.version('4.7')) {
      classpath group: 'gradle.plugin.com.github.spotbugs', name: 'spotbugs-gradle-plugin', version: '1.6.9'
    } else if (GradleVersion.current() >= GradleVersion.version('4.0')) {
      classpath group: 'gradle.plugin.com.github.spotbugs', name: 'spotbugs-gradle-plugin', version: '1.6.5'
    }
    classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: project.fg_version, changing: true
    if (GradleVersion.current() > GradleVersion.version('3.3')) {
      classpath group: 'org.checkerframework', name: 'checkerframework-gradle-plugin', version: '0.5.22'
//  } else {
//    classpath group: 'com.jaredsburrows', name: 'gradle-checker-framework-plugin', version: '0.2.1'
    }
  }
}

plugins {
//id 'com.gradle.build-scan' version '1.16' // Gradle 4.x or earlier
//id 'com.gradle.build-scan' version '3.6.3' // Gradle 5.x
//id 'com.jaredsburrows.checkerframework' version '0.2.1'// Gradle 3.3 or earlier
//id 'com.jaredsburrows.checkerframework' version '0.2.2'// Gradle 3.4/4.0 or later
//id 'com.github.spotbugs' version '4.7.1' // 1.6.5 for Gradle 4.0-4.6, 1.6.9 for Gradle 4.7+
  id 'com.matthewprenger.cursegradle' version '1.4.0'
  id 'org.sonarqube' version '3.3'
  id 'se.bjurr.gitchangelog.git-changelog-gradle-plugin' version '1.66'
//id 'org.junit.platform.gradle.plugin' version '1.2.0' // Gradle 3.5 through 4.5
  id 'jacoco'
  id 'checkstyle'
  id 'pmd'
  id 'eclipse'
  id 'idea'
  id 'maven-publish'
}

if (isFG1()) {
  apply plugin: 'forge'
} else if (isFG2()) {
  apply plugin: 'net.minecraftforge.gradle.forge'
} else if (isFG3()) {
  apply plugin: 'net.minecraftforge.gradle'
}

import org.gradle.util.GradleVersion
if (gradleNewerThan('3.4')) {
//  apply plugin: 'org.checkerframework'
} else {
//  apply plugin: 'com.jaredsburrows.checkerframework'
}

if (gradleNewerThan('4.0')) {
  apply plugin: 'com.github.spotbugs'
} else {
  apply plugin: 'findbugs'
}

import net.minecraftforge.gradle.common.task.SignJar

gradleEnterprise {
  buildScan {
    if (isOnCI()) {
      publishAlways()
    }
//  publishAlwaysIf(isOnCI())
    termsOfServiceUrl = 'https://gradle.com/terms-of-service'
    termsOfServiceAgree = 'yes'
  }
}

project.afterEvaluate {
  //final def junitPlatformTestTask = project.tasks.getByName('junitPlatformTest')

  // configure jacoco to analyze the junitPlatformTest task
  jacoco {
    // this tool version is compatible with
    toolVersion = '0.8.3' // 0.8.3 uses ASM 7.0.4, 0.8.4 uses ASM 7.1, 0.8.6 uses ASM 8.0.1, 0.8.7 uses ASM 9.1
    // Not needed with new way
    //if (gradleOlderThan('4.6')) {
      //applyTo junitPlatformTestTask
    //}
  }

  // create junit platform jacoco task
  project.task(type: JacocoReport, 'junitPlatformJacocoReport',
  {
    if (gradleNewerThan('5.0')) {
      getSourceDirectories().from(files('./src/main'))
      getClassDirectories().from(files("${project.buildDir}/classes/main"))
    } else {
      sourceDirectories = files('./src/main')
      classDirectories = files("${project.buildDir}/classes/main")
    }
    // Not needed with new way
    //if (gradleOlderThan('4.6')) {
    //  executionData junitPlatformTestTask
    //}
  })
}

// Only works with JUnit Platform Launcher 1.2.0 and earlier
if (gradleNewerThan('3.5') && gradleOlderThan('4.6')) {
  junitPlatform {
    // platformVersion '1.2.0'
    // logManager 'org.apache.logging.log4j.jul.LogManager'
    reportsDir file("${project.buildDir}/test-results/junit-platform")
    // enableStandardTestTask true
    // selectors (optional)
    // filters (optional)
  }
}

if (gradleNewerThan('4.0')) {
  spotbugs {
    ignoreFailures = true
    toolVersion = '4.2.3' // 3.1.7 uses ASM 6.2, 3.1.8 uses ASM 6.2.1
    effort = 'max'
    reportLevel = 'low'
    //includeFilter = file("$rootProject.projectDir/config/spotbugs-filter.xml")
  }

//tasks.withType(com.github.spotbugs.SpotBugsTask) { // Gradle 4.x and earlier
  tasks.withType(com.github.spotbugs.snom.SpotBugsTask) { // Gradle 5.x and later
    reports {
      if (isOnCI()) {
        xml.enabled = true
        html.enabled = false
      } else {
        xml.enabled = false
        html.enabled = true
      }
    }
  }
} else {
  findbugs {
    toolVersion = "3.0.1" // Required for Java 8
//  toolVersion = "2.0.3" // Required for Java ?
//  toolVersion = "1.3.9" // Required for Java ?
    ignoreFailures = true
    effort = 'max'
    reportLevel = 'low'
  }
}

checkstyle {
  ignoreFailures = true
  if (gradleNewerThan('2.7')) {
    toolVersion = '8.43'
  } else {
    configFile = file("${project.projectDir}/config/checkstyle/checkstyle-6.xml")
    toolVersion = '6.7' // 6.19, 6.2 - ~6.19/8.28 requires jdk7, 6.0 - 6.1.1 jdk6, 5.9 for jdk5
  }
  showViolations = false
}

pmd {
  if (gradleNewerThan('2.1')) {
    consoleOutput = false
  }
  ignoreFailures = true
  sourceSets = [sourceSets.main, sourceSets.test]
  reportsDir = file("$project.buildDir/reports/pmd")
  if (gradleNewerThan('6.8')) {
    rulesMinimumPriority = 5
  } else if (gradleNewerThan('2.8')) {
    rulePriority = 5
  }
  ruleSets = [ ]
  if (gradleNewerThan('5.6')) {
    incrementalAnalysis = true
  }
  if (gradleNewerThan('2.4')) {
    ruleSetFiles = files('config/pmd/pmd.xml')
//  ruleSetFiles = files('config/pmd/pmd-5.8.xml')
    toolVersion = '6.36.0'
//  toolVersion = '5.8.1'
  } else {
    ruleSetFiles = files('config/pmd/pmd-5.1.xml')
    toolVersion = '5.1.3'
  }
}

tasks.withType(JavaCompile) {
  options.encoding = 'UTF-8'
  options.compilerArgs = [
    '-Xlint:deprecation', // deprecation, rawtypes, cast, unchecked, all
    //'-Xdiags:verbose',
    //'-Werror'
  ]

  if (gradleNewerThan('4.6')) {
    compileJava.options.compilerArgs += '-proc:none'
  }
}

tasks.withType(Test) {
  if (gradleNewerThan('4.6')) {
    compileTestJava.options.compilerArgs += '-proc:none'
  }
}

javadoc {
  failOnError = false
}

test {
  if (gradleNewerThan('4.6')) {
    useJUnitPlatform()
    /*
    useJUnitPlatform {
      includeTags 'fast', 'smoke & feature-a'
      //excludeTags 'slow', 'ci'
      includeEngines 'junit-jupiter'
      //excludeEngines 'junit-vintage'
    }
    */
  }
}

if (project.hasProperty('mod_version')) {
  project.ext.short_version = project.mod_version
} else if (project.hasProperty('mod_version_file')) {
  ext.short_version = getModVersion((project.hasProperty('mod_version_const') ? project.mc_version : 'VERSION'), project.mod_version_file)
} else {
  project.ext.short_version = getModVersion((project.hasProperty('mod_version_const') ? project.mc_version : 'VERSION'))
}
version = (project.hasProperty('mc_version') ? project.mc_version : project.forge_mc_version) + '-' + short_version
project.ext.display_version = short_version

if ((System.getenv('BUILD_NUMBER')) || (System.getenv('TRAVIS_BUILD_NUMBER')) || (System.getenv('CIRCLE_BUILD_NUM'))) {
  version += '.' + buildNumber
  display_version += '.' + buildNumber
}

static String getBuildNumber() {
  return System.getenv('BUILD_NUMBER') ?: System.getenv('TRAVIS_BUILD_NUMBER') ?: System.getenv('CIRCLE_BUILD_NUM') ?: '0'
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8
compileJava.sourceCompatibility = JavaVersion.VERSION_1_8
compileJava.targetCompatibility = JavaVersion.VERSION_1_8

eclipse.project {
  buildCommand 'org.eclipse.buildship.core.gradleprojectbuilder'
  natures 'org.eclipse.buildship.core.gradleprojectnature'
}

idea.module {
  downloadJavadoc = true
  inheritOutputDirs = true
}

class Secrets {
  Map m_data = null

  final String getProperty(final String key) {
    return (m_data && (m_data[key] != null)) ? m_data[key] : ''
  }
}

final def secretFile
if (System.getenv('SECRET_FILE')) {
  secretFile = file System.getenv().SECRET_FILE
} else {
  secretFile = file 'secret.json'
}

import groovy.json.JsonSlurper
project.ext.secret = new Secrets()
if (secretFile.exists()) {
  secretFile.withReader {
    project.secret.m_data = new JsonSlurper().parse it
  }
} else {
  project.secret.m_data = new JsonSlurper().parseText(
    '{ "username" : "' + (System.getenv('userMaven') ?: '') + '",'
    + '"password" : "' + (System.getenv('authMaven') ?: '') + '",'
    + '"url" : "' + (System.getenv('urlMaven') ?: '') + '",'
    + '"curseforgeAPIKey" : "' + (System.getenv('curse_auth') ?: '00000000-0000-0000-0000-000000000000') + '",'
    + '"sonarHost" : "' + (System.getenv('SONAR_HOST_URL') ?: 'https://sonarcloud.io') + '",'
    + '"sonarOrganization" : "' + (System.getenv('SONAR_ORGANIZATION') ?: '') + '",'
    + '"sonarToken" : "' + (System.getenv('SONAR_TOKEN') ?: 0) + '"}'
  )
}

minecraft {
  if (isFG3()) {
    mappings channel: project.mappings_channel, version: project.mappings_version
  } else {
    version = project.forge_mc_version + '-' + project.forge_version
    if ((project.forge_mc_version != "1.6.4") && (project.forge_mc_version != "1.7.2")) {
      mappings = project.mappings_version
    }

    if ((project.fg_version != '1.0-SNAPSHOT') && (project.fg_version != '1.1-SNAPSHOT')) {
      if (project.hasProperty('runDir')) {
        runDir = project.runDir
      } else if (file('../run').exists()) {
        runDir = '../run'
      } else {
        runDir = 'run'
      }
    } else {
      if (project.hasProperty('runDir')) {
        assetDir = project.runDir
      } else if (file('../assets').exists()) {
        assetDir = '../assets'
      } else {
        assetDir = 'eclipse/assets'
      }
    }

    replace '@MOD_VERSION@', project.short_version

    if (project.hasProperty('signSHA1') && getBooleanProperty('do_sign_jar') && !isFG1()) {
      replace '@FINGERPRINT@', project.findProperty('signSHA1')
    } else {
      replace '@FINGERPRINT@', ''
    }
  }

  if (project.hasProperty('core_plugin')) {
    clientJvmArgs += "-Dfml.coreMods.load=${project.core_plugin}"
    serverJvmArgs += "-Dfml.coreMods.load=${project.core_plugin}"
  }

  if (project.hasProperty('mc_username')) {
    clientRunArgs += ['--username', project.mc_username]
    if (project.hasProperty('mc_password')) {
      clientRunArgs += ['--password', project.mc_password]
    }
  }
  if (project.hasProperty('mc_uuid')) {
    clientRunArgs += ['--uuid', project.mc_uuid]
  }

  if (getBooleanProperty('mc_server_nogui')) {
    serverRunArgs += 'nogui'
  }

  if (getBooleanProperty('forge_do_not_backup')) {
    serverJvmArgs += '-Dfml.doNotBackup=true'
    clientJvmArgs += '-Dfml.doNotBackup=true'
  }

  if (getBooleanProperty('forge_query_result_confirm')) {
    serverJvmArgs += '-Dfml.queryResult=confirm'
  }

  if (getBooleanProperty('log4j_skip_jansi')) {
    serverJvmArgs += '-Dlog4j.skipJansi=true'
    clientJvmArgs += '-Dlog4j.skipJansi=true'
  }

  if (project.hasProperty('mc_resolution')) {
    final def res = [
                     'qvga': [320, 240],
                     'vga': [640, 480],
                     'pal': [768, 576],
					 'svga': [800, 600],
					 'xga': [1024, 768],
                     '720p': [1280, 720],
					 'sxga': [1280, 1024],
					 'laptop': [1366, 768],
					 'sxgaplus': [1400, 1050],
					 'uxga': [1600, 1200],
                     '1080p': [1920, 1080],
					 'qxga': [2048, 1536],
					 '2k': [2560, 1440],
					 'qsxga': [2560, 2048],
					 '4k': [3840, 2160],
                     'custom': [project.findProperty('mc_custom_resolution_width'), project.findProperty('mc_custom_resolution_height')]]
    final def choice = res?.get(project.mc_resolution)
    if (choice != null) {
      clientRunArgs += ['--width', choice[0]]
      clientRunArgs += ['--height', choice[1]]
    }
  }

  if (project.hasProperty('client_jvm_args')) {
    clientJvmArgs += project.client_jvm_args
  }
  if (project.hasProperty('server_jvm_args')) {
    serverJvmArgs += project.server_jvm_args
  }

  if (project.hasProperty('client_game_args')) {
    clientRunArgs += project.client_game_args
  }
  if (project.hasProperty('server_game_args')) {
    serverRunArgs += project.server_game_args
  }

  if (isFG2()) {
    makeObfSourceJar = getBooleanProperty('create_source_jar')

    useDepAts = getBooleanProperty('dep_has_ats')
  }

  if (isFG3()) {
    if (project.hasProperty('mod_at_file')) {
      accessTransformer = file(findProperty('mod_at_file'))
    }

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
      client {
        workingDirectory project.file('run')

        taskName 'runClient'

        // Recommended logging data for a userdev environment
        // The markers can be changed as needed.
        // "SCAN": For mods scan.
        // "REGISTRIES": For firing of registry events.
        // "REGISTRYDUMP": For getting the contents of all registries.
        property 'forge.logging.markers', 'REGISTRIES'

        // Recommended logging level for the console
        // You can set various levels here.
        // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
        property 'forge.logging.console.level', 'debug'

        mods {
          clientRun {
            source sourceSets.main
          }
        }
      }

      server {
        workingDirectory project.file('run')

        taskName 'runServer'

        // Recommended logging data for a userdev environment
        // The markers can be changed as needed.
        // "SCAN": For mods scan.
        // "REGISTRIES": For firing of registry events.
        // "REGISTRYDUMP": For getting the contents of all registries.
        property 'forge.logging.markers', 'REGISTRIES'

        // Recommended logging level for the console
        // You can set various levels here.
        // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
        property 'forge.logging.console.level', 'debug'

        mods {
          serverRun {
            source sourceSets.main
          }
        }
      }

      data {
        workingDirectory project.file('run')

        // Recommended logging data for a userdev environment
        // The markers can be changed as needed.
        // "SCAN": For mods scan.
        // "REGISTRIES": For firing of registry events.
        // "REGISTRYDUMP": For getting the contents of all registries.
        property 'forge.logging.markers', 'REGISTRIES'

        // Recommended logging level for the console
        // You can set various levels here.
        // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
        property 'forge.logging.console.level', 'debug'

        // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
        args '--mod', project.modid, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

        mods {
          examplemod {
            source sourceSets.main
          }
        }
      }
    }
  }
}

if (isFG3()) {
  // Include resources generated by data generators.
  sourceSets.main.resources { srcDir 'src/generated/resources' }
}

repositories {
  mavenLocal()
  mavenCentral()
  maven {
    name = 'jcenter'
    url = 'https://jcenter.bintray.com/'
  }
  removeIf { it instanceof MavenArtifactRepository && it.url.host == 'files.minecraftforge.net' }
  removeIf { it instanceof MavenArtifactRepository && it.url.host == 'maven.minecraftforge.net' }
  maven {
    name = 'forge'
    url = 'https://maven.minecraftforge.net/'
  }
  maven {
    name 'MMD'
    url 'https://maven.mcmoddev.com/'
  }
}

dependencies {
  if (isFG3()) {
    minecraft "net.minecraftforge:forge:${project.forge_mc_version}-${project.forge_version}"
  }

  testImplementation('org.junit.platform:junit-platform-launcher:1.7.+') // testCompile
  testImplementation('org.junit.jupiter:junit-jupiter-api:5.7.+') // testCompile
  testRuntimeOnly('org.junit.jupiter:junit-jupiter-engine:5.7.+') // testRuntime
  if (gradleNewerThan('2.13')) {
    testCompileOnly 'junit:junit:4.13.2'
  }
  testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.7.+' //testRuntime
  testImplementation('org.mockito:mockito-core:2.+') // testCompile
  testImplementation('org.mockito:mockito-junit-jupiter:2.+') { // testCompile
    exclude group: 'org.junit.jupiter', module: 'junit-jupiter-engine'
  }
  if (gradleNewerThan('4.6')) {
    // 2.3 for Java 6, 2.4-2.12.1 for Java 7
    annotationProcessor group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.12.1'
  }
}

processResources {
  inputs.property 'version', project.short_version
  inputs.property 'mcversion', project.forge_mc_version + '-' + project.forge_version

  from (sourceSets.main.resources.srcDirs) {
    include 'mcmod.info'
    expand 'version': project.short_version, 'mcversion': project.forge_mc_version + '-' + project.forge_version
  }

  from (sourceSets.main.resources.srcDirs) {
    include 'pack.mcmeta'
    expand 'pack_format': '3', 'description': 'The default look of Example Mod'
  }

/*
  from (sourceSets.main.resources.srcDirs) {
    include 'META-INF/mods.toml'
    expand 'version': project.short_version, 'mod_name': project.name, 'mod_download': project.pom_url, 'mod_credits': '', 'mod_authors': '', 'mod_description': project.description
  }
*/

  from(sourceSets.main.resources.srcDirs) {
    exclude 'mcmod.info'
    exclude 'pack.mcmeta'
//  exclude 'META-INF/mods.toml'
  }

  if (!isFG3()) {
    rename '(.+_at.cfg)', 'META-INF/$1'
  }
}

jar {
//description = 'Creates a JAR.'
//classifier = ''
//from sourceSets.api.output
//from sourceSets.main.output

  manifest {
    mainAttributes(
      'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}",
      'Timestamp': System.currentTimeMillis(),
      'Specification-Title': project.modid,
      'Specification-Vendor': project.vendor,
      'Specification-Version': project.version,
      'Implementation-Title': project.archivesBaseName,
      'Implementation-Version': project.version,
      'Implementation-Vendor': project.vendor,
      'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
      'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
      'Built-On-Minecraft': project.forge_mc_version,
      'Built-On-Forge': project.forge_version,
      'Built-On-Mapping': project.mappings_version,
      'Built-On': "${project.forge_mc_version}-${project.forge_version}"
    )
    if (!isFG3()) {
      if (project.hasProperty('core_plugin')) {
        attributes 'FMLCorePluginContainsFMLMod': 'true'
        attributes 'FMLCorePlugin': project.core_plugin
      }
      if (project.hasProperty('mod_at_file')) {
        attributes 'FMLAT': project.mod_at_file
      }
    }
    if (project.hasProperty('mod_contained_deps')) {
      attributes 'ContainedDeps': project.mod_contained_deps
    }
  }
}

if (!isFG3()) {
  task apiJar(type: Jar) {
    onlyIf {
      getBooleanProperty('create_api_jar')
    }

    description = 'Creates a JAR containing the API Classes.'
    classifier = 'api'
    from apiClasses
//  from sourceSets.api.output
    manifest {
      mainAttributes(
        'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:api",
        'Timestamp': System.currentTimeMillis(),
        'Specification-Title': project.modid,
        'Specification-Vendor': project.vendor,
        'Specification-Version': project.version,
        'Implementation-Title': project.archivesBaseName + '-api',
        'Implementation-Version': project.version,
        'Implementation-Vendor': project.vendor,
        'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
        'Built-On-Minecraft': project.forge_mc_version,
        'Built-On-Forge': project.forge_version,
        'Built-On-Mapping': project.mappings_version,
        'Built-On': "${project.forge_mc_version}-${project.forge_version}"
      )
    }
  }
}

task deobfJar(type: Jar) {
  onlyIf {
    getBooleanProperty('create_deobf_jar')
  }

  description = 'Creates a JAR containing the non-obfuscated compiled code.'
  classifier = 'deobf'
  from sourceSets.main.output
  manifest {
    mainAttributes(
      'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:deobf",
      'Timestamp': System.currentTimeMillis(),
      'Specification-Title': project.modid,
      'Specification-Vendor': project.vendor,
      'Specification-Version': project.version,
      'Implementation-Title': project.archivesBaseName + '-deobf',
      'Implementation-Version': project.version,
      'Implementation-Vendor': project.vendor,
      'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
      'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
      'Built-On-Minecraft': project.forge_mc_version,
      'Built-On-Forge': project.forge_version,
      'Built-On-Mapping': project.mappings_version,
      'Built-On': "${project.forge_mc_version}-${project.forge_version}"
    )
    if (!isFG3()) {
      if (project.hasProperty('core_plugin')) {
        attributes 'FMLCorePluginContainsFMLMod': 'true'
        attributes 'FMLCorePlugin': project.core_plugin
      }
      if (project.hasProperty('mod_at_file')) {
        attributes 'FMLAT': project.mod_at_file
      }
    }
    if (project.hasProperty('mod_contained_deps')) {
      attributes 'ContainedDeps': project.mod_contained_deps
    }
  }
}

task devJar(type: Jar) {
  onlyIf {
    getBooleanProperty('create_dev_jar')
  }

  description = 'Creates a JAR containing the non-obfuscated compiled code.'
  classifier = 'dev'
  from sourceSets.main.output
  manifest {
    mainAttributes(
      'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:dev",
      'Timestamp': System.currentTimeMillis(),
      'Specification-Title': project.modid,
      'Specification-Vendor': project.vendor,
      'Specification-Version': project.version,
      'Implementation-Title': project.archivesBaseName + '-dev',
      'Implementation-Version': project.version,
      'Implementation-Vendor': project.vendor,
      'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
      'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
      'Built-On-Minecraft': project.forge_mc_version,
      'Built-On-Forge': project.forge_version,
      'Built-On-Mapping': project.mappings_version,
      'Built-On': "${project.forge_mc_version}-${project.forge_version}"
    )
    if (!isFG3()) {
      if (project.hasProperty('core_plugin')) {
        attributes 'FMLCorePluginContainsFMLMod': 'true'
        attributes 'FMLCorePlugin': project.core_plugin
      }
      if (project.hasProperty('mod_at_file')) {
        attributes 'FMLAT': project.mod_at_file
      }
    }
    if (project.hasProperty('mod_contained_deps')) {
      attributes 'ContainedDeps': project.mod_contained_deps
    }
  }
}

task javadocJar(type: Jar, dependsOn: javadoc) {
  onlyIf {
    getBooleanProperty('create_javadoc_jar')
  }

  description = 'Creates a JAR containing the JavaDocs.'
  classifier = 'javadoc'
  from javadoc.getDestinationDir()
  manifest {
    mainAttributes(
      'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:javadoc",
      'Timestamp': System.currentTimeMillis(),
      'Specification-Title': project.modid,
      'Specification-Vendor': project.vendor,
      'Specification-Version': project.version,
      'Implementation-Title': project.archivesBaseName + '-javadoc',
      'Implementation-Version': project.version,
      'Implementation-Vendor': project.vendor,
      'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
      'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
      'Built-On-Minecraft': project.forge_mc_version,
      'Built-On-Forge': project.forge_version,
      'Built-On-Mapping': project.mappings_version,
      'Built-On': "${project.forge_mc_version}-${project.forge_version}"
    )
  }
}

if (!isFG2()) {
  task sourceJar(type: Jar, dependsOn: classes) {
    onlyIf {
      getBooleanProperty('create_source_jar')
    }

    description = 'Creates a JAR containing the source code.'
    classifier = 'sources'
    from sourceSets.main.allSource
    manifest {
      mainAttributes(
        'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:sources",
        'Timestamp': System.currentTimeMillis(),
        'Specification-Title': project.modid,
        'Specification-Vendor': project.vendor,
        'Specification-Version': project.version,
        'Implementation-Title': project.archivesBaseName + '-sources',
        'Implementation-Version': project.version,
        'Implementation-Vendor': project.vendor,
        'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
        'Built-On-Minecraft': project.forge_mc_version,
        'Built-On-Forge': project.forge_version,
        'Built-On-Mapping': project.mappings_version,
        'Built-On': "${project.forge_mc_version}-${project.forge_version}"
      )
    }
  }
}

def signType
if (isFG1()) {
  signType = Jar
} else {
  def canSignJar = project.hasProperty('keyStore') &&
                   project.hasProperty('keyStorePass') &&
                   project.hasProperty('keyStoreKeyPass') &&
                   project.hasProperty('keyStoreAlias')
  signType = SignJar

  task signJar(type: SignJar, dependsOn: jar) {
    onlyIf {
      getBooleanProperty('do_sign_jar') &&
      canSignJar
    }

    description = 'Sign the mod jar'

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')

    inputFile = jar.archivePath
    outputFile = jar.archivePath
  }

  if (!isFG3()) {
    task signApiJar(type: SignJar) {
      onlyIf {
        getBooleanProperty('create_api_jar') &&
        getBooleanProperty('do_sign_jar') &&
        canSignJar
      }

      description = 'Sign the API jar'
      keyStore = project.findProperty('keyStore')
      alias = project.findProperty('keyStoreAlias')
      storePass = project.findProperty('keyStorePass')
      keyPass = project.findProperty('keyStoreKeyPass')

      inputFile = apiJar.archivePath
      outputFile = apiJar.archivePath
    }
  }

  task signDeobfJar(type: SignJar) {
    onlyIf {
      getBooleanProperty('create_deobf_jar') &&
      getBooleanProperty('do_sign_jar') &&
      canSignJar
    }

    description = 'Sign the deobf jar'

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')

    inputFile = deobfJar.archivePath
    outputFile = deobfJar.archivePath
  }

  task signDevJar(type: SignJar) {
    onlyIf {
      getBooleanProperty('create_dev_jar') &&
      getBooleanProperty('do_sign_jar') &&
      canSignJar
    }

    description = 'Sign the dev jar'

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')

    inputFile = devJar.archivePath
    outputFile = devJar.archivePath
  }

  task signJavadocJar(type: SignJar) {
    onlyIf {
      getBooleanProperty('create_javadoc_jar') &&
      getBooleanProperty('do_sign_jar') &&
      canSignJar
    }

    description = 'Sign the javadoc jar'

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')

    inputFile = javadocJar.archivePath
    outputFile = javadocJar.archivePath
  }

  task signSourceJar(type: SignJar) {
    onlyIf {
      getBooleanProperty('create_source_jar') &&
      getBooleanProperty('do_sign_jar') &&
      canSignJar
    }

    description = 'Sign the sources jar'

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')

//  if (!isFG3()) {
      inputFile = sourceJar.archivePath
      outputFile = sourceJar.archivePath
//  } else {
//    inputFile = sourcesJar.archivePath
//    outputFile = sourcesJar.archivePath
//  }
  }
}

if (getBooleanProperty('do_sign_jar') && (!isFG1())) {
  build.dependsOn signJar
  if (getBooleanProperty('create_api_jar') && !isFG3()) {
    build.dependsOn signApiJar
  }
  if (getBooleanProperty('create_deobf_jar')) {
    build.dependsOn signDeobfJar
  }
  if (getBooleanProperty('create_dev_jar')) {
    build.dependsOn signDevJar
  }
  if (getBooleanProperty('create_javadoc_jar')) {
    build.dependsOn signJavadocJar
  }
  if (getBooleanProperty('create_source_jar')) {
//  if (!isFG3()) {
      build.dependsOn signSourceJar
//  } else {
//    build.dependsOn signSourcesJar
//  }
  }
}

// TODO Test this
// Example configuration to allow publishing using the maven-publish task
// This is the preferred method to reobfuscate your jar file
jar.finalizedBy('reobfJar') 
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
publish.dependsOn('reobfJar')
//tasks.publish.dependsOn build
tasks.curseforge.dependsOn publish

artifacts {
  if (getBooleanProperty('create_api_jar') && !isFG3()) {
    archives apiJar
  }
  if (getBooleanProperty('create_deobf_jar')) {
    archives deobfJar
  }
  if (getBooleanProperty('create_dev_jar')) {
    archives devJar
  }
  if (getBooleanProperty('create_javadoc_jar')) {
    archives javadocJar
  }
  if (getBooleanProperty('create_source_jar')) {
//  if (!isFG3()) {
      archives sourceJar
//  } else {
//    archives sourcesJar
//  }
  }
}

//TODO: From Forge MDK
//def reobfFile = file("$buildDir/reobfJar/output.jar")
//def reobfArtifact = artifacts.add('default', reobfFile) {
//  type 'jar'
//  builtBy 'reobfJar'
//}

def maven_username = secret.username
def maven_password = secret.password
def maven_url = secret.url
publishing {
  publications {
    mavenJava(MavenPublication) {
      //TODO: From Forge MDK
      //artifact jar
      //artifact reobfArtifact
      //artifact reobfJar
      groupId project.group
      artifactId project.archivesBaseName
      version project.version
      from components.java
      if (getBooleanProperty('create_api_jar') && !isFG3()) {
        artifact apiJar {
          classifier 'api'
        }
      }
      if (getBooleanProperty('create_deobf_jar')) {
        artifact deobfJar {
          classifier 'deobf'
        }
      }
      if (getBooleanProperty('create_dev_jar')) {
        artifact devJar {
          classifier 'dev'
        }
      }
      if (getBooleanProperty('create_javadoc_jar')) {
        artifact javadocJar {
          classifier 'javadoc'
        }
      }
      if (getBooleanProperty('create_source_jar')) {
//      if (!isFG3()) {
          artifact sourceJar {
            classifier 'sources'
          }
//      } else {
//        artifact sourcesJar {
//          classifier 'sources'
//        }
//      }
      }
      if (getBooleanProperty('pom_information') && gradleNewerThan('4.8')) {
        pom {
          name = project.name
          description = project.description
          url = project.pom_url
          packaging = 'jar'
          //inceptionYear = ''
          if (getBooleanProperty('pom_license_information')) {
            licenses {
              license {
                name = project.pom_license_name
                url = project.pom_license_url
                distribution = 'repo'
                comments = project.pom_comments
              }
            }
          }
          if (getBooleanProperty('pom_scm_information')) {
            scm {
              connection = project.pom_scm_connection
              developerConnection = project.pom_scm_developer_connection
              // tag
              url = project.pom_scm_url
            }
          }
          if (getBooleanProperty('pom_issue_information')) {
            issueManagement {
              system = project.pom_issue_system
              url = project.pom_issue_url
            }
          }
          if (getBooleanProperty('pom_ci_information')) {
            ciManagement {
              system = project.pom_ci_system
              url = project.pom_ci_url
            }
          }
          if (getBooleanProperty('pom_organisation_information')) {
            organization {
              name = project.pom_organization_name
              url = project.pom_organization_url
            }
          }
          // contributors, developers, distributionManagement
        }
      }
    }
  }
  repositories {
    maven {
      if ((maven_username != '') && (maven_password != '')) {
        credentials {
          username maven_username
          password maven_password
        }
      }
      if (maven_url != '') {
        url maven_url
      } else {
        url "file:///${project.buildDir}/repo"
        //TODO: From Forge MDK
        //url "file:///${project.projectDir}/mcmodsrepo"
      }
    }
  }
}

def curseforge_api_key = secret.curseforgeAPIKey
curseforge {
  if (project.hasProperty('curseforge_project_id') &&
      project.hasProperty('curseforge_api_key') &&
      getBooleanProperty('curseforge_do_upload')) {
    apiKey = findProperty('curseforge_api_key')
    project {
      id = findProperty('curseforge_project_id')
      if (project.hasProperty('curseforge_changelog_filename')) {
        changelog = file(project.curseforge_changelog_filename)
      } else {
        changelog = ''
      }
      if (project.hasProperty('curseforge_changelog_type')) {
        changelogType = project.curseforge_changelog_type
      } else {
        changelogType = 'markdown'
      }
      if ((project.hasProperty('curseforge_release_type')) &&
         ((project.curseforge_release_type == 'alpha') ||
          (project.curseforge_release_type == 'beta') ||
          (project.curseforge_release_type == 'release'))) {
        releaseType = project.curseforge_release_type
      } else {
        releaseType = 'alpha'
      }
      if (project.hasProperty('curseforge_versions')) {
        final def versions = "${project.curseforge_versions}".split(', ')
        versions.each {
          addGameVersion "${it}"
        }
      }
      mainArtifact(jar) {
        if (getBooleanProperty('curseforge_use_custom_display_name')) {
          displayName = "${project.name} ${project.display_version}"
        }
        if (project.hasProperty('curseforge_requirements') ||
            project.hasProperty('curseforge_optionals') ||
            project.hasProperty('curseforge_embeddeds') ||
            project.hasProperty('curseforge_tools') ||
            project.hasProperty('curseforge_incompatibles')) {
          relations {
            if (project.hasProperty('curseforge_requirements')) {
              final def requirements = "${project.curseforge_requirements}".split(', ')
              requirements.each {
                requiredDependency "${it}"
              }
            }
            if (project.hasProperty('curseforge_optionals')) {
              final def optionals = "${project.curseforge_optionals}".split(', ')
              optionals.each {
                optionalDependency "${it}"
              }
            }
            if (project.hasProperty('curseforge_embeddeds')) {
              final def embeddeds = "${project.curseforge_embeddeds}".split(', ')
              embeddeds.each {
                embeddedLibrary "${it}"
              }
            }
            if (project.hasProperty('curseforge_tools')) {
              final def tools = "${project.curseforge_tools}".split(', ')
              tools.each {
                tool "${it}"
              }
            }
            if (project.hasProperty('curseforge_incompatibles')) {
              final def incompatibles = "${project.curseforge_incompatibles}".split(', ')
              incompatibles.each {
                incompatible "${it}"
              }
            }
          }
        }
      }
      if (getBooleanProperty('create_api_jar') && !isFG3()) {
        addArtifact(apiJar) {
          if (getBooleanProperty('curseforge_use_custom_display_name')) {
            displayName = "${project.name} ${project.display_version} API"
          }
        }
      }
      if (getBooleanProperty('create_deobf_jar')) {
        addArtifact(deobfJar) {
          if (getBooleanProperty('curseforge_use_custom_display_name')) {
            displayName = "${project.name} ${project.display_version} (deobf)"
          }
        }
      }
      if (getBooleanProperty('create_dev_jar')) {
        addArtifact(devJar) {
          if (getBooleanProperty('curseforge_use_custom_display_name')) {
            displayName = "${project.name} ${project.display_version} (dev)"
          }
        }
      }
      if (getBooleanProperty('create_javadoc_jar')) {
        addArtifact(javadocJar) {
          if (getBooleanProperty('curseforge_use_custom_display_name')) {
            displayName = "${project.name} ${project.display_version} Javadoc"
          }
        }
      }
      if (getBooleanProperty('create_source_jar')) {
//      if (!isFG3()) {
          addArtifact(sourceJar) {
            if (getBooleanProperty('curseforge_use_custom_display_name')) {
              displayName = "${project.name} ${project.display_version} Sources"
            }
          }
//      } else {
//        addArtifact(sourcesJar) {
//          if (getBooleanProperty('curseforge_use_custom_display_name')) {
//            displayName = "${project.name} ${project.display_version} Sources"
//          }
//        }
//      }
      }
    }
    options {
      debug = getBooleanProperty('curseforge_debug')
      javaVersionAutoDetect = true
      detectNewerJava = false
      javaIntegration = true
      forgeGradleIntegration = true
    }
  } else {
    project.logger.lifecycle('Skipping CurseForge module. No auth info provided.')
  }
}

sonarqube {
  properties {
    if (project.hasProperty('sonar_host_url')) {
      property 'sonar.host.url', project.sonar_host_url
    } else if (secret.sonarHost != '') {
      property 'sonar.host.url', secret.sonarHost
    } else {
      property 'sonar.host.url', 'https://sonarcloud.io'
    }

    if (secret.sonarToken != '') {
      property 'sonar.login', secret.sonarToken
    }

    if (project.hasProperty('sonar_organisation')) {
      property 'sonar.organization', project.sonar_organisation
    } else if (secret.sonarOrganisation != '') {
      property 'sonar.organization', secret.sonarOrganization
    } else {
      property 'sonar.organization', 'unset'
    }

    if (project.hasProperty('sonar_project_key')) {
      property 'sonar.projectKey', project.sonar_project_key
    }

    if (project.hasProperty('sonar_project_name')) {
      property 'sonar.projectName', project.sonar_project_name
    }

    if (project.hasProperty('sonar_project_description')) {
      property 'sonar.projectDescription', project.sonar_project_description
    }

    if (project.hasProperty('sonar_project_version')) {
      property 'sonar.projectVersion', project.sonar_project_version
    }

    if (project.hasProperty('sonar_branch_name')) {
      property 'sonar.branch.name', project.sonar_branch_name
    }

    if (project.hasProperty('sonar_branch_target')) {
      property 'sonar.branch.target', project.sonar_branch_target
    }

    property 'sonar.junit.reportPaths', "${project.buildDir}/test-results/junit-platform/*.xml"
    property 'sonar.jacoco.reportPaths', "${project.buildDir}/jacoco/junitPlatformTest.exec"
    //property 'sonar.groovy.jacoco.reportPath', ""
  }
}

String getModFile() {
  String path = ''
  final FileTree tree = fileTree(dir: 'src/main/java')
  tree.include '**/*.java'
  tree.visit { final element ->
    if (element.file.isFile()) {
      element.file.eachLine { final String s ->
        final String sTrim = s.trim()
        if (sTrim.startsWith('@Mod(')) {
          path = "src/main/java/${element.relativePath}"
        }
      }
    }
  }
  return path
}

String getModVersion(final String type) {
  return getModVersion(type, modFile)
}

import java.util.regex.Matcher
String getModVersion(final String type, final String modFile) {
  if ((modFile != null) && (modFile != '')) {
    final File file = file(modFile)
    final def prefix = ~/^(?:\s*)(?:(?<modifier>public|protected|private) )?(?:(?<static>static) )?(?:(?<final>final) )?String $type = "(?:(?<major>\d*)\.)?(?:(?<minor>\d*)\.)?(?:(?<patch>[^."]*)\.?)(?<build>[^"]*)";$/
    for (final String s in file.readLines()) {
      final Matcher matcher = (s.trim() =~ prefix)
      if (matcher.matches()) {
        return "${matcher.group('major') ?: '0'}.${matcher.group('minor') ?: '0'}.${matcher.group('patch')}"
      }
    }
  }
  return '0.0.0'
}

boolean isFG1() {
 return (project.fg_version == '1.0-SNAPSHOT') || (project.fg_version == '1.1-SNAPSHOT') || (project.fg_version == '1.2-SNAPSHOT')
}

boolean isFG2() {
  return (project.fg_version == '2.0-SNAPSHOT') || (project.fg_version == '2.1-SNAPSHOT') || (project.fg_version == '2.2-SNAPSHOT') || (project.fg_version == '2.3-SNAPSHOT')
}

boolean isFG3() {
  return (!isFG1() && !isFG2())
}

static boolean gradleOlderThan(final String version) {
  return GradleVersion.current() < GradleVersion.version(version)
}

static boolean gradleNewerThan(final String version) {
  return GradleVersion.current() >= GradleVersion.version(version)
}

static boolean isOnCI() {
  return System.getenv('CI')
}

boolean getBooleanProperty(final String property) {
  if (project.hasProperty(property)) {
    return ((String) project.findProperty(property)).toBoolean()
  } else {
    return false
  }
}

if (gradleNewerThan('2.1')) {
  task gitChangelog(type: se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask) {
    file = new File('CHANGELOG.md')
    gitHubIssuePattern = "nonada123"
    templateContent = file('changelog.mustache').getText('UTF-8')
  }
}

Object findProperty(final String propertyName) {
  return hasProperty(propertyName) ? property(propertyName) : null
}

/*
checkerFramework {
  checkers = [
//    'org.checkerframework.checker.units.UnitsChecker',
    'org.checkerframework.checker.nullness.NullnessChecker'
  ]
}
*/

if (gradleNewerThan('3.3')) {
  task writeServerProperties(type: WriteProperties) {
    description = 'Configures the server with default properties. Eg. Disables online mode.'

    outputFile = file('run/server.properties')

    property('allow-flight', 'true')
    property('difficulty', 'easy') // peaceful, easy, normal, hard
    property('enable-command-block', 'true')
    property('gamemode', 'survival') // survival, creative, adventure, spectator

    property('level-name', project.modid)
    property('level-seed', project.modid)
    property('level-type', 'default') // default, flat, largeBiomes, amplified

    property('motd', "Testing server for ${project.name}")
    property('online-mode', 'false')

    property('pvp', 'true')

    property('server-ip', '')
    property('server-port', '25565')

    property('snooper-enabled', 'false')
    property('spawn-protection', '0')
  }

  task acceptEula(type: WriteProperties) {
    description = 'Automatically creates and agrees to the Mojang account EULA.'

    outputFile = file('run/eula.txt')

    property 'eula', true

    doLast {
      project.logger.warn("You have agreed to Mojang's EULA! https://account.mojang.com/documents/minecraft_eula");
    }
  }
}
